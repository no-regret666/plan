# TCP/IP网络模型

对于同一台设备上的进程间通信，有很多种方式，比如有管道、消息队列、共享内存、信号等方式，而对于不同设备上的进程间通信，就需要网络通信，而设备是多样性的，所以要兼容多种多样的设备，就协商出了一套**通用的网络协议**。



故事从键入一个网址开始

## 应用层

为用户提供应用功能，比如HTTP、FTP、Telnet、DNS、SMTP等

### 解析URL

<img src="/home/noregret/.config/Typora/typora-user-images/image-20240522205914341.png" alt="image-20240522205914341" style="zoom:33%;" />

当没有路径名时，就代表访问根目录下事先设置的**默认文件**，也就是 `/index.html` 或者 `/default.html` 这些文件，这样就不会发生混乱了。



### HTTP请求消息

![image-20240523204454908](/home/noregret/.config/Typora/typora-user-images/image-20240523204454908.png)

**1.请求行**

请求行由请求方法、URI和HTTP版本号3个字段组成，它们用空格分隔。例如，GET /index.html HTTP/1.1。

常见的请求方法：

<img src="/home/noregret/.config/Typora/typora-user-images/image-20240522210335828.png" alt="image-20240522210335828" style="zoom:33%;" />

写好方法之后,加一个空格,然后写 URI。URI 部分的格式如下,一般是文件和程序的路径名。
/< 目录名 >/.../< 文件名 >

**2.消息头**

存放一些额外的详细信息，如日期、客户端支持的数据类型、语言等

**3.消息体**

需要发送的数据



### 响应消息

![image-20240523212007875](/home/noregret/.config/Typora/typora-user-images/image-20240523212007875.png)

在响应消息中,第一行的内容为状态码和响应短语,用来表示请求的执行结果是成功还是出错。

状态码是一个数字,它主要用来向程序告知执行的结果；

相对地,响应短语则是一段文字,用来向人们告知执行的结果。



### 真实地址查询——DNS

浏览器自身并不具备将消息发送到网络中的功能，而是需要委托操作系统来实现。在委托操作系统发送消息时，必须要提供通信对象的IP地址。因此在生成HTTP消息之后，下一个步骤就是根据域名查询IP地址。

比如我们打电话的时候，必须要知道对方的电话号码，但由于电话号码难以记忆，所以通常我们会将对方电话号 + 姓名保存在通讯录里。

所以，有一种服务器就专门保存了 `Web` 服务器域名与 `IP` 的对应关系，它就是 `DNS` 服务器。

```c
struct hostent *gethostbyname(const char *name);
//用域名或主机名获取IP地址
```

DNS 中的域名都是用句点来分隔的，比如 www.server.com，这里的句点代表了不同层次之间的界限。

在域名中，越靠右的位置表示其层级越高。

毕竟域名是外国人发明，所以思维和中国人相反，比如说一个城市地点的时候，外国喜欢从小到大的方式顺序说起（如 XX 街道 XX 区 XX 市 XX 省），而中国则喜欢从大到小的顺序（如 XX 省 XX 市 XX 区 XX 街道）。

实际上域名最后还有一个点，比如 www.server.com.，这个最后的一个点代表根域名。

也就是，. 根域是在最顶层，它的下一层就是 .com 顶级域，再下面是 server.com。

所以域名的层级关系类似一个树状结构：

- 根 DNS 服务器（.）
- 顶级域 DNS 服务器（.com）
- 权威 DNS 服务器（server.com）

<img src="/home/noregret/.config/Typora/typora-user-images/image-20240523220830195.png" alt="image-20240523220830195" style="zoom:33%;" />

根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。

这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。

因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。



通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的**协议栈**。

## 传输层

主要负责在网络中建立端到端的连接，提供可靠的数据传输。

<img src="/home/noregret/.config/Typora/typora-user-images/image-20240516223206235.png" alt="image-20240516223206235" style="zoom: 33%;" />

协议：数据在网络中传输的规则，常见的协议有UDP、TCP、http、https、ftp

增加TCP头部，包含端口号、序列号



### 端口号

由两个字节表示的整数，取值范围：0~65535

其中0~1023之间的端口号用于一些知名的网络服务或者应用

我们自己使用1024以上的端口号就可以了



**！！！一个端口号只能被一个应用程序使用**





### TCP协议

#### 1. 什么是TCP协议

TCP是面向连接的协议，这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先相互“握手”，即它们必须相互发送某些预备报文段，以建立确保数据传输的参数。它有以下几个特点：

- **面向连接**：TCP一定是“一对一”的，无法像 UDP 协议那样在同一时刻像多个主机发送消息，即无法做到一对多；
- **可靠的**：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端（当然不是说绝对可靠）；
- **基于字节流**：消息是“没有边界”的，所以无论我们消息有多大都可以进行传输。并且消息是“有序的”，当前一个消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对重复的报文会自动丢弃。

#### 2. 为什么需要TCP协议，它在哪一层工作？

IP 层是“不可靠”的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中数据的完整性。如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。因为 TCP 是一个工作在**传输层**的**可靠**数据传输的服务，它能确保接收端接收的网络包是**无损坏、无间隔、非冗余和按序的。**

### 创建套接字

<img src="/home/noregret/.config/Typora/typora-user-images/image-20240524180453742.png" alt="image-20240524180453742" style="zoom:33%;" />

协议栈的内部分为几个部分，分别承担不同的功能。

套接字的实体就是通信控制信息：在协议栈内部有一块用于存放控制信息的内存空间,这里记录了用于控制通信操作的控制信息,例如通信对象的 IP 地址、端口号、通信操作的进行状态等。协议栈在执行操作时需要参阅这些控制信息。

<img src="/home/noregret/.config/Typora/typora-user-images/image-20240524183019392.png" alt="image-20240524183019392" style="zoom:33%;" />

首先是创建套接字。应用程序调用 socket 申请创建套接字,协议栈根据应用程序的申请执行创建套接字的操作。在这个过程中,协议栈会分配用于存放一个套接字所需的内存空间，写入这一初始状态的控制信息。

接下来,需要将表示这个套接字的描述符告知应用程序。描述符相当于用来区分协议栈中的多个套接字的号码牌。收到描述符之后,应用程序在向协议栈进行收发数据委托时就需要提供这个描述符。 通过描述符能确定相应的套接字，协议栈就能获取通信双方的信息以及通信处于怎样的状态。



### TCP报文头部

<img src="/home/noregret/.config/Typora/typora-user-images/image-20240524185336517.png" alt="image-20240524185336517" style="zoom:33%;" />

首先，**源端口号**和**目标端口**号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。

接下来有包的**序**号，这个是为了解决包乱序的问题。

还有应该有的是**确认号**，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决丢包的问题。

接下来还有一些**状态位**。例如 `SYN` 是发起一个连接，`ACK` 是回复，`RST` 是重新连接，`FIN` 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。

还有一个重要的就是**窗口大小**。TCP 要做**流量控制**，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。

除了做流量控制以外，TCP还会做**拥塞控制**，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。



### 连接服务器

创建套接字之后,应用程序(浏览器)就会调用 connect,随后协议栈会将本地的套接字与服务器的套接字进行连接。

#### 连接的目的

- 将服务器的IP地址和端口号等信息告知协议栈，从而确定通信对象。
- 客户端向服务器传达开始通信的请求

#### 三次握手

<img src="/home/noregret/.config/Typora/typora-user-images/image-20240524224530536.png" alt="image-20240524224530536" style="zoom:33%;" />

第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN-SENT状态，等待服务器的确认；

第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN-RECD状态；

第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

完成了三次握手，客户端和服务器端就可以开始传送数据。

> 为什么是三次握手？

1. **避免历史连接（主要原因）**

   三次握手的主要原因是为了防止旧的重复连接初始化造成混乱。

   网络环境是比较复杂的，它不一定能保证我们先发送的数据包就一定能再我们期望的时间内送达，它可能半路 Poor Gay 了。也有可能超时后再抵达服务端，那么这时的TCP就会产生以下的一种情况：

   <img src="/home/noregret/.config/Typora/typora-user-images/image-20240525160334908.png" alt="image-20240525160334908" style="zoom:33%;" />

   如上图所示，如果一个SYN报文再超时后没有得到响应，客户端可能再次发送一个新的SYN请求，而这时旧的SYN请求可能比新的SYN请求先达到服务器。如果此时没有第三次连接来确认此次连接是否是历史连接的话，那么双方可能会建立两个连接？造成数据混乱。而如果是三次连接的话，客户端就有机会再去确认或者中止掉错误的连接，**防止历史连接初始化了连接**。

   **如果是两次握手连接，就无法阻止历史连接**，因为**在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费**。

   <img src="/home/noregret/.config/Typora/typora-user-images/image-20240525161149346.png" alt="image-20240525161149346" style="zoom: 33%;" />

   **要解决这种现象，最好就是在服务端发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手**。

2. **同步双方初始序列号**

   TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：

   - 接收方可以去除重复的数据；
   - 接收方可以根据数据包的序列号按序接收；
   - 可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；

   可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 `SYN` 报文的时候，需要服务端回一个 `ACK` 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，**这样一来一回，才能确保双方的初始序列号能被可靠的同步。**

   <img src="/home/noregret/.config/Typora/typora-user-images/image-20240525161526899.png" alt="image-20240525161526899" style="zoom: 50%;" />

   四次握手其实也能够可靠的同步双方的初始化序号，但由于**第二步和第三步可以优化成一步**，所以就成了「三次握手」。

   而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。

3. **避免资源浪费**

   如果只有「两次握手」，当客户端发生的 `SYN` 报文在网络中阻塞，客户端没有接收到 `ACK` 报文，就会重新发送 `SYN` ，**由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 `ACK` 报文，所以服务端每收到一个 `SYN` 就只能先主动建立一个连接**，这会造成什么情况呢？

   如果客户端发送的 `SYN` 报文在网络中阻塞了，重复发送多次 `SYN` 报文，那么服务端在收到请求后就会**建立多个冗余的无效链接，造成不必要的资源浪费。**

   <img src="/home/noregret/.config/Typora/typora-user-images/image-20240525163830585.png" alt="image-20240525163830585" style="zoom: 33%;" />

   即两次握手会造成消息滞留情况下，服务端重复接受无用的连接请求 `SYN` 报文，而造成重复分配资源。

*小结*

TCP 建立连接时，通过三次握手**能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号**。序列号能够保证数据包不重复、不丢弃和按序传输。

不使用「两次握手」和「四次握手」的原因：

- 「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
- 「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数



### TCP传输过程的控制

#### 1. 如何提高数据传输的可靠性

从上面我们聊TCP连接的建立过程，我们可以知道，当客户端的数据达到接收主机的时候，服务端主机会返回一个已收到消息的通知。这个消息就是前面提到的应答消息（ACK）。这个消息机制具体的实现就是，每次当接收端收到对端发送过来的消息时，都会将对端消息中的序列号+1，作为自己消息发送的应答号。

[![img](https://img2020.cnblogs.com/blog/1614350/202012/1614350-20201209214326648-592921487.png)](https://img2020.cnblogs.com/blog/1614350/202012/1614350-20201209214326648-592921487.png)

TCP通过肯定的确认应答（ACK）实现可靠的数据传输。当发送端将数据发送之后等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。反之，则数据丢失的可能性很大。当在一定时间内没有收到确认应答，发送端就认为数据已经丢失，那么就会进行重新发送。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。这个过程如下所示：

[![img](https://img2020.cnblogs.com/blog/1614350/202012/1614350-20201209214339011-1696970517.png)](https://img2020.cnblogs.com/blog/1614350/202012/1614350-20201209214339011-1696970517.png)

当然还有另外一种情况，就是主机B已经收到了数据，丢失确认应答的消息在传输过程中丢失，那么此时主机A在一段时间内没有收到确认应答消息，也会认为主机B没有收到消息，从而再发送一次，如下图：

[![img](https://img2020.cnblogs.com/blog/1614350/202012/1614350-20201209214400072-325268092.png)](https://img2020.cnblogs.com/blog/1614350/202012/1614350-20201209214400072-325268092.png)

这种情况在传输并不鲜见，如果一直收到主机A发送的重复数据，对于主机B来说，它必须去放弃一些重复的包，这就需要我们上面所提到的序列号了。根据序列号判断这个数据包先前是否收到过，如果收到过就放弃，如果没有收到就保留。序列号的生成有其独特算法，这里就不做赘述了。

#### 2. 超时重发如何确定

重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 `ACK` 确认应答报文，就会重发该数据，也就是我们常说的**超时重传**。

TCP 会在以下两种情况发生超时重传：

- 数据包丢失
- 确认应答丢失

<img src="/home/noregret/.config/Typora/typora-user-images/image-20240525170211608.png" alt="image-20240525170211608" style="zoom: 50%;" />

上图中有两种超时时间不同的情况：

- 当超时时间 **RTO 较大**时，重发就慢，丢了老半天才重发，没有效率，性能差；
- 当超时时间 **RTO 较小**时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。

精确的测量超时时间 `RTO` 的值是非常重要的，这可让我们的重传机制更高效。

由于ACK号的返回时间会产生很大的波动，还要考虑拥塞带来的影响，所以将超时时间设置为一个固定值并不是一个好办法。因此,TCP 采用了动态调整超时时间的方法,这个超时时间是根据 ACK 号返回所需的时间来判断的。具体来说，TCP 会在发送数据的过程中持续测量 ACK 号的返回时间,如果 ACK 号返回变慢,则相应延长等待时间;相对地,如果 ACK 号马上就能返回,则相应缩短等待时间。

#### 3. 利用窗口控制提高速度

我们都知道 TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。这种方式的缺点是效率比较低的。

这样的传输方式有一个缺点：数据包的**往返时间越长，通信的效率就越低**。

为解决这个问题，TCP 引入了**窗口**这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。

那么有了窗口，就可以指定窗口大小，窗口大小就是指**无需等待确认应答，而可以继续发送数据的最大值**。

窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。

假设窗口大小为 `3` 个 TCP 段，那么发送方就可以「连续发送」 `3` 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：

<img src="/home/noregret/.config/Typora/typora-user-images/image-20240525173346322.png" alt="image-20240525173346322" style="zoom: 50%;" />

图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫**累计确认**或者**累计应答**。

> 窗口大小由哪一方决定？

TCP 头里有一个字段叫 `Window`，也就是窗口大小。

**这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。**

所以，通常窗口的大小是由接收方的窗口大小来决定的。

发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。

### 终止连接（四次挥手）

<img src="/home/noregret/.config/Typora/typora-user-images/image-20240525181131265.png" alt="image-20240525181131265" style="zoom: 33%;" />

#### 1. TCP四次挥手的过程

- 现在客户端与服务端都处在连接建立的状态，假设此时客户端想要关闭连接；
- 【第一个报文】：客户端发送一个 FIN 报文，用来关闭客户端到服务端的数据传送，也就是客户端告诉被服务端：我已经不会再给你发数据了(当然，在 FIN 包之前发送出去的数据，如果没有收到对应的 ACK 报文，客户端依旧会重发这些数据)，但此时客户端还可以接受数据；
- 【第二个报文】：服务端收到 FIN 报文后，发送一个 ACK 给对方，确认序号为收到序号 + 1，此时服务端进入 CLOSED_WAIT 状态。客户端接收到 ACK 报文后，进入 FIN_WAIT_2 状态；
- 【第三个报文】：服务端发送一个 FIN 报文，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了，接下来服务端进入 LAST_ACK 状态；
- 【第四个报文】：客户端收到 FIN 报文之后，发送一个 ACK 给服务端，确认应答号为收到序号 + 1，此时客户端进入 TIME_WAIT 状态；
- 服务端收到 FIN 报文后，就直接进入了 CLOSED 状态，连接资源将被释放，四次挥手到此结束；
- 客户端在经过 2MSL 时间后，自动进入CLOSED 状态，至此客户端也完成了连接的关闭。

#### 2.为什么挥手需要四次？

再来回顾下四次挥手双方发 `FIN` 包的过程，就能理解为什么需要四次了。

- 关闭连接时，客户端向服务端发送 `FIN` 时，仅仅表示客户端不再发送数据了但是还能接收数据。
- 服务端收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接。

从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 `ACK` 和 `FIN` 一般都会分开发送，因此是需要四次挥手。



之后需要等待一段时间再删除套接字，这是为了防止误操作。举一个例子：加入客户端先发起断开，则断开的操作顺序为                                            		       (1)客户端发送 FIN
(2)服务器返回 ACK 号
(3)服务器发送 FIN																														(4)客户端返回 ACK 号																						               				           如果最后客户端返回的 ACK 号丢失了,?这时,服务器没有接收到 ACK 号,可能会重发一次 FIN。如果此时套接字已经被删除，那么套接字中保存的控制信息也就跟着消失了,套接字对应的端口号就会被释放出来。这时,如果别的应用程序要创建套接字,新套接字碰巧又被分配了同一个端口号 ,而服务器重发的 FIN 正好到达,这个FIN就会错误的跑到新套接字中，新套接字就开始执行断开操作了。



### UDP协议

特点：

- 无连接、不可靠
- 高效性、低延迟
- 支持一对一、一对多、多对一和多对多的交互通信
- 缺乏流量控制和拥塞控制机制

应用场景：不需要重发的数据用 UDP 发送更高效，控制用的短数据例如DNS解析等交换控制信息的操作，音频和视频数据......



## 网络层

主要负责网络地址的分配和路由选择。

<img src="/home/noregret/.config/Typora/typora-user-images/image-20240519215642579.png" alt="image-20240519215642579" style="zoom: 33%;" />

### IP协议

IP协议会将传输层的报文作为数据部分，再加上IP包头（包含源IP地址和目标IP地址）组装成IP报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会**再次进行分片**，得到一个即将发送到网络的 IP 报文。

### IP地址

设备在网络中的地址，是唯一的标识

### IPv4地址

采用32位地址长度，分为4组，比如192.168.100.1

#### 寻址

先匹配到相同的网络号（表示要找到同一个子网），再去找对应的主机

IP地址具有两种意义：

- 一个是**网络号**，负责表示该IP地址是属于哪个「子网」的
- 一个是**主机号**，负责标识同一「子网」下的不同主机

区分方式：

1. 表示形式 `a.b.c.d/x`，其中 `/x` 表示前 x 位属于**网络号**， x 的范围是 `0 ~ 32`，这就使得 IP 地址更加具有灵活性。

   比如 10.100.122.2/24，/24 表示前 24 位是网络号，剩余的 8 位是主机号。

   <img src="/home/noregret/.config/Typora/typora-user-images/image-20240525195143145.png" alt="image-20240525195143145" style="zoom:50%;" />

2. 根据子网掩码 255.255.255.0

​       将10.100.122.2和255.255.255.0进行**按位与运算**，得到网络号

​       将255.255.255.0取反后与IP地址进行**按位与运算**，得到主机号

#### 公有IP地址和私有IP地址

比如192.168.开头的就是私有地址，范围为192.168.0.0--192.168.255.255，专门为组织机构内部使用，以此节省IP

#### 路由控制

除了寻址能力， IP 协议还有另一个重要的能力就是**路由**。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。

#### 特殊IP地址

127.0.0.1，也可以是localhost：是回送地址也称本地回环地址，也称本机IP，永远只会寻找当前所在本机



### IPv6地址

采用128位地址长度，分为8组



## 网络接口层

生成了 IP 头部之后，接下来要交给**网络接口层**（*Link Layer*）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。

<img src="/home/noregret/.config/Typora/typora-user-images/image-20240520214432218.png" alt="image-20240520214432218" style="zoom:33%;" />

什么是以太网呢？电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。

以太网通过匹配MAC头部判断网络包目的地。

MAC头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。



## 服务器

包装好的数据包经过网卡、交换机、路由器，长途跋涉终于来到了服务器。服务器高兴的不得了，于是开始扒数据包的皮！

<img src="/home/noregret/.config/Typora/typora-user-images/image-20240525201157836.png" alt="image-20240525201157836" style="zoom: 50%;" />



数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。

接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。

于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。

于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。

服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。

HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。

穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。

最后跳到了客户端的城门把守的路由器，路由器扒开 IP 头部发现是要找城内的人，于是又把包发给了城内的交换机，再由交换机转发到客户端。

客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！

于是，客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！

最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。

